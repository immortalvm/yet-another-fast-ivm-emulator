# Yet another (fast) IVM emulator

**The parallel output of this branch is based on processes instead of threads.
It includes one single .c file and two headers.**

This ivm64 emulator takes an ivm64 binary and emulates its execution. It benefits from two kind of optimizations:

  * Optimized execution of common instruction patterns generated by the c compiler
  * Parallel execution of output instructions

### Requirements 

For versions with I/O, library png is needed. 

In a deb based linux distribution, it can be installed as:

```bash
sudo apt update
sudo apt install libpng-dev
```

### How to compile?

```
    make # generates the next executables
    gcc -Ofast -DWITH_IO  ivm_emu.c -lpng -o ivm_emu
    gcc -Ofast            ivm_emu.c -o ivm_emu_no_io # The fastest one without input/ouput but put_char
    gcc -Ofast -DWITH_IO  ivm_emu.c -lpng -DPARALLEL_OUTPUT -pthread -o ivm_emu_parallel # Parallel IO
    gcc -Ofast -DWITH_IO  ivm_emu.c -lpng -DNOOPT -DSTEPCOUNT -DVERBOSE=2 -o ivm_trace2
    gcc -Ofast -DWITH_IO  ivm_emu.c -lpng -DNOOPT -DSTEPCOUNT -DVERBOSE=3 -o ivm_trace3
    gcc -Ofast -DWITH_IO  ivm_emu.c -lpng -DNOOPT -DSTEPCOUNT -DVERBOSE=1 -DHISTOGRAM -o ivm_histo

    # the following options are for debugging and they can make the execution slower:
    gcc -Ofast -DNOOPT     ivm_emu.c  # Disable optimizations
    gcc -Ofast -DSTEPCOUNT ivm_emu.c  # Enable instruction count, show probes if used
    gcc -Ofast -DVERBOSE=1 ivm_emu.c  # Some extra info
    gcc -Ofast -DVERBOSE=2 ivm_emu.c  # Trace mode (show instruction sequence)
    gcc -Ofast -DVERBOSE=3 ivm_emu.c  # Detailed trace mode (instr. and stack content sequence)
    gcc -Ofast -DHISTOGRAM ivm_emu.c  # Enable insn. pattern histogram

     Number of processes for the version with parallel output:
     * Default: 8
     * if compiled with -DNUM_THREADS=N1, N1 is used instead of the default value
     * if environment variable export NUM_THREADS=N2, N2 is used instead of N1 or default
     * In any case, the parallel version uses at least 2 threads, in general:
                1 thread for emulation and (N-1) thread for io

	 Note that this number refers to forked processes, although named NUM_THREADS

```

### How to execute?

Options keep compatibility with the original ivm implementation.

```ivm_emu [-m <size in bytes>] [-a <arg file>] [-i <input dir>] [-o <output dir>] <ivm_binary_file> ```


### DEBUGGING

Version v1.12 of ```ivm_emu``` can be compiled to generate executables that are useful for
debugging. Examples of this capabilities are: ```ivm_histo```, ```ivm_trace2``` and ```ivm_trace3```.

To allow dynamically activation/deactivation of program tracing, and to extract information of
executed instructions in a code section, the ```Yet another IVM emulator``` admits three unnused
opcodes: 0xf0, 0xf1, 0xf2 and 0xf3.

In directory ```samples```, a C code using this facility can be found: ```30_hanoi_probe.c```.
This sample code includes the header ```probe.h``` which contains the macros to easily insert the
appropiate opcodes into the C code (as if they were function calls).

After this, compile the program and assemble it:
```ivm64-gcc 30_hanoi_probe.c -o 30_hanoi_probe -DWITH_IVM64_PROBES```
```ivm as 30_hanoi_probe```

At this point, the binary contains non-standard opcodes, so it can not be executed using ```vm```.

Execute the binary using Yet another IVM emulator:
```ivm_probe 30_hanoi_probe.b```

The program makes it normal execution, printing all its output and at the end, the emulator
print the gathered information, for example:

```
Binary file size: 172315 bytes (172.3 KB)
Executed 38070971 instructions

Probe   0:      13732
Probe   1:     180166
Probe   2:       2936
Probe   3:   37874142
End stack:
0x..000000 0

```
Probes can also be read from the program if requiered using ```ivm64_probe_read()```.

To obtain a binary without the non-standard opcodes, just compile the program without WITH_IVM64_PROBES:
```ivm64-gcc 30_hanoi_probe.c -o 30_hanoi_probe```

This way, all sentences like  ```ivm64_set_probe(1)```,```ivm64_trace_off```,```ivm64_trace_hard```,
etc, are ignored.



### Execution times

These experiments were conducted on an Intel(R) Core(TM) i7-3770 CPU @ 3.40GHz, where the emulator was compiled with gcc 7.4.0.

Code static_unboxing was compiled with gcc 10.2.0-ivm64-2.0. This code has no I/O instructions but ```put_char```.

Code ex4_short_video.s is one of the example codes provided with the ivm application.

Binaries generated with ivm v0.37.

| benchmark                      | no optimization | optimized |  optimized +  parallel io |
|--------------------------------|-----------------|-----------|---------------------------|
| static_unboxing                |1m30s            | 35s       |               |
| ex4_short_video.s (512 frames) |7s               | 3.6s      |  1.8s         |

